---
title: "devoir MAN 2016"
author: "sarah FELDMAN"
date: "21 octobre 2016"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Q1/Dans un premier temps décrivez vos variables.
```{r , echo=FALSE,warning=FALSE,message=FALSE}
library(psy)
library(corrplot)
library(gridExtra)
library(ggplot2)
library(car)
library(dplyr)
library(grid)
library(knitr)

rt <- read.csv2("data/presentationTPretinol.csv")
```

## Nombre de variables
```{r cars}
dim(rt)
```
J'ai 14 variables.

## Type de variables
#Attention transformer summary et le sortir après transformation en facteur : nb de données, nb de NA, MinMax, Moy,Med, Q1,Q3
```{r, echo=FALSE, cache=TRUE}
summary(rt)
rt$sexe.bin <- factor(Recode(rt$sexe,"1=0;2=1"))
rt$vitamine.f <- factor(rt$vitamine)
rt$tabac.f <- factor (rt$tabac)
```
Les variables sont toutes reconnues comme quantitatives 
mais en regardant plus attentivement les min et max on peut voir que certaines variables ne sont pas quantitatives:
  + sexe a un minimum de 1 et un maximum de 2 c'est donc une variables qualitative binaire. Je la    recode en 0(homme)/1(femme) pour une interprétation plus facile par la suite et je la transforme en facteur.
  + Les variables tabac et vitamine sont des variables qualitatives ordinales, il y a bien un ordre dans les classes mais je ne peux pas dire si l'espace entre 2 classes est le même. Pour tabac par exemple : ne pas fumer versus fumer anciennement aura-t-elle la même différence d'effet que fumer anciennement versus fumer actuellement? Je préfère donc les coder comme des variables qualitatives en attendant d'en savoir plus. Pour cela je les transforme simplement en facteur.

Les autres variables sont quantitatives continues:
age, bmi, calories, graisses, fibres, alcool, cholestérol, betadiet,retdiet,betaplasma,retplasma

```{r , echo=FALSE}
quantcont<- c("age", "bmi", "calories", "graisses", "fibres", "alcool", "cholestérol","betadiet","retdiet","betaplasma","retplasma")
qual.ord <- c("tabac","vitamine","", "", "", "", "", "", "", "", "")
binaire <- c("sexe","", "", "", "", "", "", "", "", "","")
#grid.table(cbind(variables.quantitatives.continues=quantcont,variables.quantitatives.discretes=quantdis,variable.binaire=binaire))
kable(cbind(variables.quantitatives.continues=quantcont,variables.qualitatives.orinales=qual.ord,variable.binaire=binaire))
```

## Données manquantes : Pas indispensable
summary ne montre pas de données manquantes mais je préfère m'en assurer en demandant spécifiquement de sortir les NA:
```{r, echo=FALSE }
  for (i in names(rt)){
    res <-  c(i,sum(is.na(rt[ , i])))
    .df<-data.frame(variables=res[1],"NA"=res[2])
    if(which(names(rt)==i)==1).res <- .df else .res <- rbind(.res,.df) 
  }
print(.res)
```

# Données abberrantes

Observer ses variables sert également à dépister les "bizarreries".
Par exemple, j'ai un doute concernant le max d'alcool, je vais donc regarder plus attentivement la variable, par exemple avec une table
```{r}
table(rt$alcool)

```
en effet, je passe de 35 à 203 verres...203/7=29 verres par jour, il y a probablement un erreur de codage

#Que faire du 203 d'alcool?

## Distribution des variables
```{r ,message=FALSE, echo=FALSE}

#par(mfrow=c(2,3))
non_cont<- c("sexe","tabac","vitamine")
names_rt<-names(rt)[! names(rt) %in% non_cont]
qage <- qplot(rt$age,binwidth=1)
qbmi <- qplot(rt$bmi,binwidth=1)
qcalories <- qplot(rt$calories,binwidth=50)
qgraisses <- qplot(rt$graisses,binwidth=2)
qfibres <- qplot(rt$fibres,binwidth=0.5)
qalcool <- qplot(rt$alcool,binwidth=3)
qcholesterol <- qplot(rt$cholesterol,binwidth=50)
qbetadiet <- qplot(rt$betadiet,binwidth=40)
qretdiet <- qplot(rt$retdiet,binwidth=40)
qbetaplasma <- qplot(rt$betaplasma,binwidth=30)
qretplasma <- qplot(rt$retplasma,binwidth=30)

# for (i in names_rt){
#   assign(paste0("q",i),qplot(rt[,i],
#               geom="histogram",
#               binwidth = 0.5,
#               #main=i,
#               xlab=i))
#   #print(hist(rt[,i],breaks = 20, main=i)) 
# } 
# grid.arrange(get(paste0("q",names_rt)))

# noquote(paste(noquote(paste0("q",names_rt)),collapse=","))
# grid.arrange(qage,qbmi,qcalories,qgraisses,qfibres,qalcool,qcholesterol,qbetadiet,qretdiet,qbetaplasma,qretplasma)

#dev.off() #produce a null device message

pl <- lapply(names_rt, function(.x) qplot(rt[,.x],xlab=NULL, main=paste("plot", .x)))
ml <- marrangeGrob(pl,ncol=2,nrow=3,top = NULL)
print(ml)
```
```{r, echo=FALSE}

varnorm<- c("retplasma", "bmi", "cholesterol", "retdiet", "graisses", "betadiet", "betaplasma", "calories", "fibres")
#rep("",length(varnorm)-length(varnnorm))
varnnorm<-c("age", "sexe", "tabac", "vitamine", "alcool","", "", "", "")

#grid.table(cbind(variables.normales=varnorm,variables.non.normales=varnnorm))
kable(cbind(variables.normales=varnorm,variables.non.normales=varnnorm))

```

-bmi, graisses, cholestérol, betadiet, retdiet et betaplasme on des distribution à peu près normales mais asymétriques.
-calories, fibres, ret plasma ont de distributions d'allure normales
-age a une distribution irrégulière avec 2 cloches à 40 et 75 ans.
-alcool a une distribution très asymétrique qui ne semble pas normale

# Exemple d'autres façons de représenter des variables :
### barplot pour tabac
### boxplot pour âge

# Q2/Etudiez les relations existant entre toutes les paires possibles de variables. 
NB : ce ne sont que les 9 variables de la régression demandé en question 3 qui sont concernées
```{r,echo=FALSE}
var <- c("retplasma","age","sexe","bmi","tabac","vitamine","cholesterol","alcool","retdiet") 
#var %in% names(rt)#pour voir quelle variable j'ai mal recopié

```
Je peux faire une matrice de corrélation.
Aucune condition n'est nécessaire pour faire des coefficients de corrélation. C'est pour les tester que nous avons besoin de vérifier les confidions de validité
```{r, echo = FALSE}
mat <- round(cor(rt[,var]),3)
#print(mat)
kable(mat)
```

scatter plot?
Il faut ensuite interprêter la matrice. Pour cela je peux faire des schéma

```{r , echo=FALSE}
corrplot(cor(rt[,var]),method="circle")
```

```{r, echo=FALSE}
mdspca(rt[,var])
```

bmi, tabac et vitamine sont très proches du centre du cercle donc non interprétables
Par contre on peut voir que les paires retdiet-cholestérol, retplasma-age sont fortement associés (corrélation positive), et ces deux groupes de variables sont indépendants l'un de l'autre car forme un angle droit avec le centre.
sexe est également indépendant de retdiet et cholestérol.
Alcool-sexe est négativement corrélée

Je peux aussi sélectionner dans la matrice les valeurs absolues supérieures ou égales à certain niveau de corrélation
```{r,echo=FALSE}
couples<-lapply(c(0.2,0.4),function(w){
  #pour supprimer les doublons
  mat2<- lower.tri(mat,diag=FALSE);rownames(mat2)<-rownames(mat) ; colnames(mat2) <- colnames(mat) 
  mat2 <- ifelse(mat2==TRUE,mat,0)
  #pour chercher les coefficients de corrélation superieur à w
  w_r <- which(abs(mat2)>=w )
  #pour trouver les noms de ligne et colonne de ces coefficients
  which_couple <- lapply(w_r,function(x){
    k <- arrayInd(x, dim(mat2))
    #paste(rownames(mat2)[k[,1]],"-", colnames(mat2)[k[,2]])
    data.frame(var1=rownames(mat2)[k[,1]], var2=colnames(mat2)[k[,2]],r=mat2[x])
  })
  #Je colle les listes
  #browser()
  which_couple <- data.frame(do.call(rbind,which_couple))
  #Je nomme les 2 listes de niveau supérieur selon la valeur du coefficient
  #colnames(which_couple) <- c(paste0("var1.r",w),paste0("var2.r",w)) 
  return(which_couple)
})
print(couples)

```

Est-ce pertinent de faire de tests de corrélation pour chaque variable?


Attention aux conditions de validité: 
une des 2 variables du couple testé doit être normale
```{r, echo=FALSE}
couplesb <- couples[[1]]
couplesb$testvalid <- ifelse( couplesb$var1 %in% varnorm | couplesb$var2 %in% varnorm,TRUE,FALSE) 
couplesb$test<-sapply(1:nrow(couplesb), function(x) {
  .var1 <- couplesb[x,1]
  .var2 <- couplesb[x,2]
  #browser()
  .var1rt <- rt[,as.character(.var1)]
  .var2rt <- rt[,as.character(.var2)]
  testcouple<-cor.test(.var1rt,.var2rt)
  # if couplesb$testvalid[x] testcouple<-cor.test(.var1rt,.var2rt)
  # else testcouple <- cor.test(.var1rt,.var2rt, method="spearman") #je préfère ne pas utiliser du non paramétrique car m'empêcherait de faire des analyses plus poussées ensuite
  ##browser()
  pcor<-round(testcouple$p.value,5)
  return(pcor)
})

print(couplesb)
#couples$test <- cor.test(get(paste0("rt$",var1)),get(paste0("rt$",var2)))
```

Pour r>=0.2, 5 couples ressortent:
age-retplasma, sexe_age, cholesterol-sexe, alcool-sexe,retdiet-cholestérol

Il n'y a qu'un couple qui ressort pour r>=0.4 :
retdiet-cholestérol



# Q3/Effectuez ensuite une régression linéaire où la variable à expliquer sera la concentration en rétinol plasmatique, les autres variables étant explicatives. Recherchez des interactions entre les variables explicatives. 


## ACP focalisée

Je peux commencer par regarder les intéraction enter retplasma  et les variables explicatives avec une acp focalisée:
```{r , echo=FALSE}
var <- c("retplasma","age","sexe","bmi","tabac","vitamine","cholesterol","alcool","retdiet") 
my_formula<-as.formula(paste("retplasma~",paste(var[-1],collapse='+'))) #pour éviter de tout réécrire à la main...
fpca(formula = my_formula,data=rt)
```
La seule variable qui semble significativement liée à retplasma est âge. Et en effet c'est un couple qui ressortait dans la matrice de corrélation avec un r=0.212 significativement différent de 0.

## régression linéaire multiple

La variable à expliquer retplasma étant une variable Quantitative, je peux faire une régression linéaire. Et dans la mesure où j'introduis plusieurs variables explicatives, ce sera une régression linéaire multiple.

```{r,echo=FALSE }
mod <- lm(my_formula,rt)
#mod <- lm(retplasma ~ age + sexe * bmi + tabac + vitamine + cholesterol + alcool + retdiet,rt) #idem

```
### Vérification des conditions de validité:
Il y a 3 conditions de validité aux modèles :
  + la normalité de bruit
  + la variance du bruit ne doit dépendre ni de la variable à expliquer ni de la variable explicative
  + le bruit doit être du vrai bruit
En pratique on ne teste que la première des conditions:
```{r , echo=FALSE}
hist(resid(mod))
```
La distribution des résidus a une allure normale, mon modèle est donc valide

```{r , echo=FALSE}
summary(mod)
drop1(mod) 
```

## Recherche d'intéractions entre les variables explicatives:
```{r, echo=FALSE}
mod_inter <- data.frame(add1(mod,~.^2,test="Chisq"))
isort <- order (mod_inter$Pr..Chi.)
mod_order <- mod_inter[isort,]
mod_order$Pr..Chi. <- round(mod_order$Pr..Chi.,4) 
mod_order$signif <- ifelse(mod_order$Pr..Chi.<= 0.05,"*","")

mytheme <- ttheme_default(base_size=10)

a <-tableGrob(mod_order[1:14,], rows = rownames(mod_order)[1:14],theme = mytheme)
b <- tableGrob(mod_order[15:nrow(mod_order),], rows = rownames(mod_order)[15:nrow(mod_order)],theme = mytheme)
.df<-mod_order 
kable(.df)
# grid.draw(a)
# grid.newpage()
# grid.draw(b)
#grid.arrange(a,b,nrow=2)
```

Je trace la représentation graphique des pvalue des 28 intéractions possibles
```{r, echo=FALSE}
x <- 1-na.omit(mod_order$Pr..Chi.)
y <- length(x):1
plot(x,y,xlab="1-p",ylab="Np")
line<- lm(1:length(x) ~ -1 + x[length(x):1])
abline(line)
```


# Q4/Transformez la variable "rétinol plasmatique" en une variable binaire (en la coupant en deux au niveau de la médiane). Refaites les calculs précédents en ayant recours cette fois à une régression logistique.

## régression logistique : construction du modèle
La variable à expliquer est binaire, il faut donc faire une régression logistique
```{r, echo=FALSE}
rt$retplasma.bin <- ifelse(rt$retplasma < median(rt$retplasma,na.rm=TRUE), 0,1)
mod.bin <- glm(retplasma.bin ~ age + sexe + bmi + tabac + vitamine + cholesterol + alcool + retdiet, data = rt, family = "binomial")
```
### Vérification des conditions de validité
pour que le modèle soit valide, il faut au moins 5 à 10 évènements par variable explicative.
J'ai 6 variables explicatives comptant comme une variable, et 2 variables comptant comme n(classe) - 1 variables soit 2 pour vitamines et 2 pour tabac (sexe est binaire et ne compte donc que pour une variable).
J'ai donc un total de 10 variables.
10*5=50
10*10=100
# ? A vérifier dans le bouquin
retplasma : c=157 sujets n'ont pas la variable, 158 l'ont. Donc 158 sujets ont des variables explicatives
100 est inférieur à 158 donc le modèle est valable! 
```{r , echo=FALSE}


```

```{r , echo=FALSE}
summary(mod.bin)
drop1(mod.bin) 
```

## Recherche d'intéractions entre les variables explicatives:
```{r, echo=FALSE}
mod_inter.bin <- data.frame(add1(mod.bin,~.^2,test="Chisq"))
isort.bin <- order (mod_inter.bin$Pr..Chi.)
mod_order.bin <- mod_inter.bin[isort.bin,]
mod_order.bin$Pr..Chi. <- round(mod_order.bin$Pr..Chi.,4) 
mod_order.bin$signif <- ifelse(mod_order.bin$Pr..Chi.<= 0.05,"*","")

mytheme <- ttheme_default(base_size=10)

a <-tableGrob(mod_order.bin[1:14,], rows = rownames(mod_order.bin)[1:14],theme = mytheme)
b<-tableGrob(mod_order.bin[15:nrow(mod_order.bin),], rows = rownames(mod_order.bin)[15:nrow(mod_order.bin)],theme = mytheme)

.df.bin <- mod_order.bin
kable(.df.bin)
# grid.draw(a)
# grid.newpage()
# grid.draw(b)

#grid.arrange(a,b,ncol=2)
```

Je trace la représentation graphique des pvalue des 28 intéractions possibles
```{r, echo=FALSE}
x <- 1-na.omit(mod_order.bin$Pr..Chi.)
y <- length(x):1
plot(x,y,xlab="1-p",ylab="Np")
line<- lm(1:length(x) ~ -1 + x[length(x):1])
abline(line)
```
